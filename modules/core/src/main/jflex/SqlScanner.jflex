package com.tsurugidb.console.core.parser;

import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;

@SuppressFBWarnings(
    justification = "generated by JFlex"
)
%%

%class SqlScannerFlex
%unicode
%ignorecase

%type int
%eofval{
    return eof();
%eofval}

%char
%line
%column

%{
    static final int SAW_EOF = -1;

    static final int SAW_DELIMITER = 0;

    static final int SAW_BODY = 1;

    private Segment.Builder buffer = new Segment.Builder();

    private boolean textContinue = false;
    private int textStartLine = -1;
    private int textStartColumn = -1;
    private long textStartOffset = -1;

    Segment build() {
        return buffer.build();
    }

    private int skip() {
        // track whitespaces only if the current segment is in active (chops the leading spaces)
        if (buffer.isInitialized()) {
            flushUnhandled();
            appendText();
        }
        return SAW_BODY;
    }

    private int token(TokenKind kind) {
        initialize();
        flushUnhandled();
        appendText();
        buffer.addToken(new TokenInfo(kind, buffer.relative(yychar), yylength(), yyline, yycolumn));
        if (kind.isStatementDelimiter()) {
            return SAW_DELIMITER;
        }
        return SAW_BODY;
    }

    private int unhandled() {
        initialize();
        appendText();
        if (!textContinue) {
            textStartLine = yyline;
            textStartColumn = yycolumn;
            textStartOffset = yychar;
            textContinue = true;
        }
        return SAW_BODY;
    }

    private int eof() {
        initialize();
        flushUnhandled();
        buffer.addToken(new TokenInfo(TokenKind.EOF, buffer.relative(yychar), 0, yyline, yycolumn));
        return SAW_EOF;
    }
    
    private void initialize() {
        if (!buffer.isInitialized()) {
            buffer.initialize(yychar);
        }
    }
    
    private void appendText() {
        buffer.append(yytext());
    }

    private boolean flushUnhandled() {
        if (textContinue) {
            long textEndOffset = yychar;
            buffer.addToken(new TokenInfo(
                    TokenKind.UNHANDLED_TEXT,
                    buffer.relative(textStartOffset),
                    (int) (textEndOffset - textStartOffset),
                    textStartLine,
                    textStartColumn));
            textStartLine = -1;
            textStartColumn = -1;
            textStartOffset = -1;
            textContinue = false;
        }
        return true;
    }
%}

LETTER = [A-Za-z_]

DIGIT = [0-9]

WHITE_SPACES  = [ \t]+

LINE_BREAK  = [\r\n]+

HYPHEN_COMMENT = "--" [^\r\n]*

SLASH_COMMENT = "//"  [^\r\n]*

BLOCK_COMMENT = "/*" ~ "*/"


REGULAR_IDENTIFIER = {LETTER} ( {LETTER} | {DIGIT} )*

DELIMITED_IDENTIFIER = "\"" ( "\\" . | [^\\\"] )* "\""

NUMERIC_LITERAL = ( {DIGIT}+ ( "." {DIGIT}* )? | "." {DIGIT}+ ) ( "E" [+\-]? {DIGIT}+ )?

TRUE_LITERAL = "TRUE"

FALSE_LITERAL = "FALSE"

NULL_LITERAL = "NULL"

CHARACTER_STRING_LITERAL = "'" ( "\\" . | [^\\'] )* "'"

BINARY_STRING_LITERAL = "X" {CHARACTER_STRING_LITERAL}

SPECIAL_COMMAND_LETTER = [^ \t\r\n\"\';]

SPECIAL_COMMAND = "\\" {SPECIAL_COMMAND_LETTER}*

SPECIAL_COMMAND_ARGUMENT = {SPECIAL_COMMAND_LETTER}+

// punctuations or operators
DOT = "."
COMMA = ","
SEMICOLON = ";"
LEFT_PAREN = "("
RIGHT_PAREN = ")"
PLUS = "+"
MINUS = "-"
ASTERISK = "*"
EQUAL = "="
BACK_SLASH = "\\"

%state SQL_BODY
%state COMMAND_BODY

%%

{WHITE_SPACES}              { /* keep state */ return skip(); }

// comments
{HYPHEN_COMMENT}            { /* keep state */ return token(TokenKind.HYPHEN_COMMENT); }
{SLASH_COMMENT}             { /* keep state */ return token(TokenKind.SLASH_COMMENT); }
{BLOCK_COMMENT}             { /* keep state */ return token(TokenKind.BLOCK_COMMENT); }

<YYINITIAL, SQL_BODY> {
    {LINE_BREAK}                { /* keep state */ return skip(); }

    // values
    {TRUE_LITERAL}              { yybegin(SQL_BODY); return token(TokenKind.TRUE_LITERAL); }
    {FALSE_LITERAL}             { yybegin(SQL_BODY); return token(TokenKind.FALSE_LITERAL); }
    {NULL_LITERAL}              { yybegin(SQL_BODY); return token(TokenKind.NULL_LITERAL); }
    {REGULAR_IDENTIFIER}        { yybegin(SQL_BODY); return token(TokenKind.REGULAR_IDENTIFIER); }
    {DELIMITED_IDENTIFIER}      { yybegin(SQL_BODY); return token(TokenKind.DELIMITED_IDENTIFIER); }
    {NUMERIC_LITERAL}           { yybegin(SQL_BODY); return token(TokenKind.NUMERIC_LITERAL); }
    {CHARACTER_STRING_LITERAL}  { yybegin(SQL_BODY); return token(TokenKind.CHARACTER_STRING_LITERAL); }
    {BINARY_STRING_LITERAL}     { yybegin(SQL_BODY); return token(TokenKind.BINARY_STRING_LITERAL); }

    // punctuations or operators
    {DOT}                       { yybegin(SQL_BODY); return token(TokenKind.DOT); }
    {COMMA}                     { yybegin(SQL_BODY); return token(TokenKind.COMMA); }
    {SEMICOLON}                 { yybegin(YYINITIAL); return token(TokenKind.SEMICOLON); }
    {LEFT_PAREN}                { yybegin(SQL_BODY); return token(TokenKind.LEFT_PAREN); }
    {RIGHT_PAREN}               { yybegin(SQL_BODY); return token(TokenKind.RIGHT_PAREN); }
    {PLUS}                      { yybegin(SQL_BODY); return token(TokenKind.PLUS); }
    {MINUS}                     { yybegin(SQL_BODY); return token(TokenKind.MINUS); }
    {ASTERISK}                  { yybegin(SQL_BODY); return token(TokenKind.ASTERISK); }
    {EQUAL}                     { yybegin(SQL_BODY); return token(TokenKind.EQUAL); }
    {BACK_SLASH}                { yybegin(SQL_BODY); return token(TokenKind.BACK_SLASH); }
}

<YYINITIAL> {
    {SPECIAL_COMMAND}           { yybegin(COMMAND_BODY); return token(TokenKind.SPECIAL_COMMAND); }
}

<COMMAND_BODY> {
    {LINE_BREAK}                { yybegin(YYINITIAL); return token(TokenKind.LINE_BREAK); }
    {DELIMITED_IDENTIFIER}      { yybegin(COMMAND_BODY); return token(TokenKind.DELIMITED_IDENTIFIER); }
    {CHARACTER_STRING_LITERAL}  { yybegin(COMMAND_BODY); return token(TokenKind.CHARACTER_STRING_LITERAL); }
    {SPECIAL_COMMAND_ARGUMENT}  { yybegin(COMMAND_BODY); return token(TokenKind.SPECIAL_COMMAND_ARGUMENT); }
    {SEMICOLON}                 { yybegin(YYINITIAL); return token(TokenKind.SEMICOLON); }
}

// unhandled text
[^]                         { yybegin(SQL_BODY); return unhandled(); }
